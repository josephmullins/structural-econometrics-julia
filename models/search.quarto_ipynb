{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Job Search Model\n",
        "\n",
        "## Overview\n",
        "\n",
        "This section presents a simple model of undirected job search. The model demonstrates how workers optimally choose which job offers to accept based on a reservation wage strategy. \n",
        "\n",
        "\n",
        "## Economic Environment\n",
        "\n",
        "Time is discrete and indexed by $t$ over an infinite horizon. Workers move between employment and unemployment, have linear utility, and cannot save.\n",
        "\n",
        "### Parameters\n",
        "\n",
        "| Parameter | Description | \n",
        "| --------- | ------------|\n",
        "| $\\lambda$ | The probability an unemployed worker receives a job offer | \n",
        "| $\\delta$  | The probability an employed worker loses their job | \n",
        "| $F_{W}$   | The distribution of wage offers | \n",
        "| $1-\\beta$   | The exponential rate of discounting | \n",
        "| $b$       | Per-period utility when unemployed | \n",
        "\n",
        "## Recursive Formulation\n",
        "\n",
        "The classic approach to solve this model is to write the values of unemployment and employment recursively. For example:\n",
        "\n",
        "$$ U = b + \\beta[(1-\\lambda)U + \\lambda\\int\\max\\{V(w),U\\}dF_{W}(w)] $$\n",
        "$$ V(w) = w + \\beta[(1-\\delta)V(w) + \\delta U] $$\n",
        "\n",
        "## Model solution\n",
        "\n",
        "One can show that the optimal decision rule of the worker is characterized by a reservation wage $w^*$, defined as $V(w^*)=U$. We can also differentiate the expression for $V(w)$ to get:\n",
        "\n",
        "$$ V'(w) = \\frac{1}{1 - \\beta(1-\\delta)} $$\n",
        "\n",
        "and applying integration by parts gives:\n",
        "\n",
        "$$ U = b + \\beta[U + \\lambda\\int_{w^*}\\frac{1-F_{W}(w)}{1-\\beta(1-\\delta)}dw] $$\n",
        "\n",
        "Now applying the definition of the reservation wage gives the reservation wage equation:\n",
        "\n",
        "$$ w^* = b + \\beta\\lambda\\int_{w^*}\\frac{1-F_{W}(w)}{1 - \\beta(1-\\delta)}dw $$\n",
        "\n",
        "and we can characterize the steady state rate of unemployment as:\n",
        "\n",
        "$$ P[E = 0] = \\frac{h}{h+\\delta} $$\n",
        "\n",
        "where $h = \\lambda(1-F_{W}(w^*))$ is the rate at which workers exit unemployment. \n",
        "\n",
        "Similarly, we can show that the steady state fraction of unemployment durations $t_{U}$ is\n",
        "\n",
        "$$ P[t_{U}=t] = h(1-h)^{t} $$\n",
        "\n",
        "## Numerical Model Solution\n",
        "\n",
        "To solve the reservation wage equation numerically, we need to evaluate the integral on the right-hand side and find the value of $w^*$ that satisfies the equation. This requires two key numerical methods: quadrature (for integration) and root-finding.\n",
        "\n",
        "### Gauss-Legendre Quadrature\n",
        "\n",
        "When integrating numerically, we approximate the integral using a weighted sum at specific evaluation points (nodes):\n",
        "\n",
        "$$ \\int_a^b f(x)dx \\approx \\frac{b-a}{2}\\sum_{k=1}^n w_k f\\left(\\frac{a+b}{2} + \\frac{b-a}{2}x_k\\right) $$\n",
        "\n",
        "where $x_k$ are the nodes and $w_k$ are the weights from Gauss-Legendre quadrature. This method is particularly accurate for smooth functions and uses a fixed number of nodes, which is important for [automatic differentiation](/appendices/autodiff.qmd) (unlike adaptive methods like in the package `QuadGK` that adjust the number of nodes based on the integrand).\n",
        "\n",
        "Let's implement a simple Gauss-Legendre integration routine:\n"
      ],
      "id": "a65bf410"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using FastGaussQuadrature, Distributions, Roots\n",
        "\n",
        "# Fixed-node quadrature for integration (compatible with automatic differentiation)\n",
        "function integrateGL(f, a, b; num_nodes = 10)\n",
        "    nodes, weights = gausslegendre(num_nodes)\n",
        "    ∫f = 0.\n",
        "    for k in eachindex(nodes)\n",
        "        x = (a + b)/2 + (b - a)/2 * nodes[k]\n",
        "        ∫f += weights[k] * f(x)\n",
        "    end\n",
        "    return (b - a)/2 * ∫f\n",
        "end\n",
        "\n",
        "# Evaluate the derivative of the surplus function\n",
        "dS(x; F, β, δ) = (1 - cdf(F, x)) / (1 - β*(1 - δ))\n",
        "\n",
        "# Reservation wage equation (should equal zero at the solution)\n",
        "function res_wage(wres, b, λ, δ, β, F::Distribution)\n",
        "    ub = quantile(F, 0.9999)  # Upper bound of integration\n",
        "    integral = integrateGL(x -> dS(x; F, β, δ), wres, ub)\n",
        "    return wres - b - β * λ * integral\n",
        "end\n",
        "\n",
        "pars = (;b = -5., λ = 0.45, δ = 0.03, β = 0.99, F = LogNormal(1, 1))\n",
        "res_wage(1., pars.b, pars.λ, pars.δ, pars.β, pars.F)"
      ],
      "id": "f9339dbf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Root Finding\n",
        "\n",
        "The reservation wage $w^*$ is the value that makes the reservation wage equation equal to zero. We use the `Roots.jl` package, which implements efficient root-finding algorithms based on combinations of bisection, secant, and inverse quadratic interpolation methods.\n",
        "\n",
        "The `find_zero` function takes:\n",
        "\n",
        "- A function to find the root of\n",
        "- An initial guess\n",
        "- The type of the initial guess (to ensure type stability)\n"
      ],
      "id": "d649a3b1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function solve_res_wage(b, λ, δ, β, F)\n",
        "    return find_zero(\n",
        "        x -> res_wage(x, b, λ, δ, β, F),\n",
        "        eltype(b)(4.)  # Initial guess of $4/hour\n",
        "    )\n",
        "end\n",
        "\n",
        "rwage = solve_res_wage(pars.b, pars.λ, pars.δ, pars.β, pars.F)\n",
        "println(\"Reservation wage: \", round(rwage, digits=2))"
      ],
      "id": "2b3f7201",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This approach has the advantage of being compatible with [automatic differentiation](/appendices/autodiff.qmd) tools like `ForwardDiff`, which is a very useful tool in numerical methods.\n",
        "\n",
        "### Steady-State Statistics\n",
        "\n",
        "Using the computed reservation wage, we can calculate the steady-state unemployment rate and average duration:\n"
      ],
      "id": "afb1aabc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute steady-state statistics\n",
        "h = pars.λ * (1 - cdf(pars.F, rwage))  # Exit rate from unemployment\n",
        "u_rate = pars.δ / (pars.δ + h)          # Unemployment rate\n",
        "avg_duration = 1 / h                     # Average duration\n",
        "\n",
        "println(\"Exit rate (h): \", round(h, digits=3))\n",
        "println(\"Unemployment rate: \", round(u_rate * 100, digits=1), \"%\")\n",
        "println(\"Average duration: \", round(avg_duration, digits=1), \" periods\")"
      ],
      "id": "d3c267ad",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "\n",
        "## Further Reading\n",
        "\n",
        "- **McCall (1970)**: \"Economics of Information and Job Search\" - Original search model\n",
        "- **Wolpin (1987)**: \"Estimating a Structural Search Model\" - Early structural estimation\n",
        "- **Eckstein and van den Berg (2007)**: \"Empirical Labor Search\" - Survey of search models\n",
        "- **Flinn and Heckman (1982)**: \"New Methods for Analyzing Structural Models of Labor Force Dynamics\" - Duration data analysis\n"
      ],
      "id": "0c5733ec"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/Users/mullinsj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}