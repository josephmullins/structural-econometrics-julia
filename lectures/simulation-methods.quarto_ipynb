{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Simulation Methods\n",
        "\n",
        "In many structural models, the likelihood or moment conditions cannot be computed in closed form because they involve high-dimensional integrals over unobserved heterogeneity, latent states, or expectations over future shocks. The savings model is a good example: even if we knew the true parameters, computing the likelihood of an observed consumption path requires integrating over sequences of income shocks. In these settings, **simulation** provides a way forward.\n",
        "\n",
        "This chapter covers three topics. First, we discuss **simulation-based estimators** --- the method of simulated moments (MSM) and indirect inference --- which replace intractable analytical objects with simulation approximations. Second, we introduce the **bootstrap**, a general resampling-based approach to inference that is particularly useful when analytical standard errors are difficult to derive. Third, we bring these tools together with our prototype models.\n",
        "\n",
        "## Integration by Simulation\n",
        "\n",
        "At the heart of simulation-based estimation is the problem of computing integrals. Suppose we need to evaluate:\n",
        "\n",
        "$$f(y|\\mathbf{x},\\theta) = \\int h(y|\\mathbf{x},\\theta,\\mathbf{u})g(\\mathbf{u})d\\mathbf{u}$$\n",
        "\n",
        "where $\\mathbf{u}$ is a vector of unobservables with density $g$. If the dimension of $\\mathbf{u}$ is large or $h$ does not admit a closed-form integral, we can approximate by **Monte Carlo integration**: draw $\\mathbf{u}^{1},\\ldots,\\mathbf{u}^{R}$ from $g$ and compute:\n",
        "\n",
        "$$\\hat{f}(y|\\mathbf{x},\\theta) = \\frac{1}{R}\\sum_{r=1}^{R}h(y|\\mathbf{x},\\theta,\\mathbf{u}^{r})$$\n",
        "\n",
        "By the law of large numbers, $\\hat{f}\\rightarrow_{p} f$ as $R\\rightarrow\\infty$. This is unbiased by construction: $\\mathbb{E}_{\\mathbf{u}}[\\hat{f}]=f$.\n",
        "\n",
        "### Importance Sampling\n",
        "\n",
        "Sometimes we want to draw from an alternative density $w(\\mathbf{u})$ instead of $g(\\mathbf{u})$ --- for instance because $g$ is hard to sample from, or because draws from $w$ reduce the variance of the estimator. In this case:\n",
        "\n",
        "$$\\hat{f}(y|\\mathbf{x},\\theta) = \\frac{1}{R}\\sum_{r=1}^{R}h(y|\\mathbf{x},\\theta,\\mathbf{u}^{r})\\frac{g(\\mathbf{u}^{r})}{w(\\mathbf{u}^{r})},\\qquad \\mathbf{u}^{r}\\sim w$$\n",
        "\n",
        "This is still unbiased and consistent, and the choice of $w$ can substantially reduce variance. The ratio $g/w$ is called the **importance weight**.\n",
        "\n",
        "## Maximum Simulated Likelihood\n",
        "\n",
        "A natural first idea is to replace the likelihood with its simulated analogue. The **maximum simulated likelihood (MSL)** estimator is:\n",
        "\n",
        "$$\\hat{\\theta}_{MSL} = \\arg\\max_{\\theta}\\sum_{n=1}^{N}\\log\\hat{f}(y_{n}|\\mathbf{x}_{n},\\theta)$$\n",
        "\n",
        "where $\\hat{f}$ is the simulated probability from above.\n",
        "\n",
        ":::{.callout-important}\n",
        "## A Subtlety with MSL\n",
        "\n",
        "There is an important issue with MSL: because $\\log$ is concave, Jensen's inequality gives $\\mathbb{E}[\\log\\hat{f}]\\leq \\log\\mathbb{E}[\\hat{f}]=\\log f$. This means the simulated log-likelihood is *biased downward*, and the MSL estimator is inconsistent for fixed $R$. Consistency requires that the number of simulation draws grows with the sample: both $N,R\\rightarrow\\infty$ with $\\sqrt{N}/R\\rightarrow 0$.\n",
        "\n",
        "This is in contrast to the method of simulated moments, which we discuss next, where a fixed number of simulation draws is sufficient for consistency.\n",
        ":::\n",
        "\n",
        "Under standard regularity conditions and $\\sqrt{N}/R\\rightarrow 0$, the MSL estimator has the same asymptotic distribution as the (infeasible) MLE:\n",
        "\n",
        "$$\\sqrt{N}(\\hat{\\theta}_{MSL}-\\theta_{0})\\rightarrow_{d}\\mathcal{N}(\\mathbf{0},\\ \\mathcal{I}(\\theta_{0})^{-1})$$\n",
        "\n",
        "In practice, one should use enough draws that the simulation error is small relative to the sampling variability. A common rule of thumb is to set $R$ large enough that results are insensitive to further increases.\n",
        "\n",
        "## Method of Simulated Moments\n",
        "\n",
        "The **method of simulated moments (MSM)** is the simulation analogue of GMM. Suppose that the moment conditions take the form:\n",
        "\n",
        "$$\\mathbb{E}[g(\\mathbf{w},\\theta_{0})] = \\mathbb{E}\\left[\\int h(\\mathbf{w},\\theta_{0},\\mathbf{u})f(\\mathbf{u}|\\theta_{0})d\\mathbf{u}\\right] = \\mathbf{0}$$\n",
        "\n",
        "If we cannot evaluate $g$ analytically, we can replace it with a simulated version:\n",
        "$$\\hat{g}(\\mathbf{w}_{n},\\theta) = \\frac{1}{R}\\sum_{r=1}^{R}\\tilde{g}(\\mathbf{w}_{n},\\mathbf{u}^{r},\\theta)$$\n",
        "\n",
        "where $\\mathbb{E}_{\\mathbf{u}}[\\tilde{g}(\\mathbf{w},\\mathbf{u},\\theta)]=g(\\mathbf{w},\\theta)$. The MSM estimator is:\n",
        "\n",
        "$$\\hat{\\theta}_{MSM} = \\arg\\min_{\\theta}\\ \\hat{\\mathbf{g}}_{N}(\\theta)'\\mathbf{W}\\hat{\\mathbf{g}}_{N}(\\theta),\\qquad\\hat{\\mathbf{g}}_{N}(\\theta) = \\frac{1}{N}\\sum_{n=1}^{N}\\hat{g}(\\mathbf{w}_{n},\\theta)$$\n",
        "\n",
        "### A Common Special Case\n",
        "\n",
        "In many structural applications, the moment conditions do not involve observation-level simulation. Instead, we match *aggregate* statistics from the data to their model-implied counterparts computed by simulating the model. The moments take the form:\n",
        "\n",
        "$$\\hat{\\mathbf{g}}_{N}(\\theta) = \\hat{\\mathbf{m}} - \\tilde{\\mathbf{m}}(\\theta)$$\n",
        "\n",
        "where $\\hat{\\mathbf{m}}$ is a vector of sample statistics (means, variances, covariances, etc.) and $\\tilde{\\mathbf{m}}(\\theta)$ is the corresponding vector computed from simulated data. This is the structure we will use for the savings model below.\n",
        "\n",
        "### Asymptotic Distribution\n",
        "\n",
        ":::{#thm-msm-asymptotics}\n",
        "## Asymptotic Distribution of MSM\n",
        "Suppose the standard regularity conditions for GMM hold and $\\mathbb{E}_{\\mathbf{u}}[\\tilde{g}(\\mathbf{w},\\mathbf{u},\\theta)]=g(\\mathbf{w},\\theta)$. Then with $R$ fixed:\n",
        "\n",
        "$$\\sqrt{N}(\\hat{\\theta}_{MSM}-\\theta_{0})\\rightarrow_{d}\\mathcal{N}(\\mathbf{0},\\Sigma_{MSM})$$\n",
        "\n",
        "where:\n",
        "$$\\Sigma_{MSM} = (\\nabla_{\\theta}g_{0}\\mathbf{W}\\nabla_{\\theta}g_{0}')^{-1}\\nabla_{\\theta}g_{0}\\mathbf{W}\\mathbb{E}[\\hat{g}_{0}\\hat{g}_{0}']\\mathbf{W}\\nabla_{\\theta}g_{0}'(\\nabla_{\\theta}g_{0}\\mathbf{W}\\nabla_{\\theta}g_{0}')^{-1}$$\n",
        "\n",
        "with $\\nabla_{\\theta}g_{0}=\\mathbb{E}[\\nabla_{\\theta}g(\\mathbf{w},\\theta_{0})']$.\n",
        ":::\n",
        "\n",
        "Several features are worth highlighting:\n",
        "\n",
        "1. **Consistency does not require $R\\rightarrow\\infty$.** Because $\\hat{g}$ is an unbiased estimator of $g$, the simulated sample moments converge to zero at $\\theta_{0}$ by the law of large numbers. This is in contrast to MSL.\n",
        "2. **Simulation adds variance.** Because $\\mathbb{V}[\\hat{g}]\\geq\\mathbb{V}[g]$, the MSM estimator is less efficient than the infeasible GMM estimator that uses the true $g$. For the common case of a **frequency simulator** (where $\\tilde{g}$ is a binary indicator), the variance inflates by a factor of $(1+1/R)$.\n",
        "3. **If $\\sqrt{N}/R\\rightarrow 0$**, the efficiency loss from simulation disappears and the MSM achieves the same asymptotic variance as GMM.\n",
        "\n",
        "See @newey1994large for a comprehensive treatment.\n",
        "\n",
        "\n",
        ":::{.callout-note icon=\"false\" collapse=\"true\"}\n",
        "## Example: Simulating the Savings Model\n",
        ":::{#exm-simulate_savings}\n",
        "\n",
        "To estimate the savings model by MSM, we first need to be able to **simulate** data from it. Given a solution (the policy function $A$), we can forward-simulate a panel of individuals by drawing income shocks and applying the optimal savings rule.\n"
      ],
      "id": "8616392d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using Distributions, Random, LinearAlgebra, Statistics\n",
        "\n",
        "# === Model setup (from savings model chapter) ===\n",
        "Φ_cdf(x) = cdf(Normal(),x)\n",
        "\n",
        "function tauchen(ρ,ση,Kϵ)\n",
        "    sd = ση/sqrt(1-ρ^2)\n",
        "    grid = range(-3sd,stop=3sd,length=Kϵ)\n",
        "    Π = zeros(Kϵ,Kϵ)\n",
        "    Δ = grid[2]-grid[1]\n",
        "    for j=1:Kϵ\n",
        "        Π[1,j] = Φ_cdf((grid[1] + Δ/2 - ρ*grid[j])/ση)\n",
        "        Π[end,j] = 1 - Φ_cdf((grid[end] - Δ/2 - ρ*grid[j])/ση)\n",
        "        for k=2:(Kϵ-1)\n",
        "            Π[k,j] = Φ_cdf((grid[k] + Δ/2 - ρ*grid[j])/ση) - Φ_cdf((grid[k] - Δ/2 - ρ*grid[j])/ση)\n",
        "        end\n",
        "    end\n",
        "    return Π,collect(grid)\n",
        "end\n",
        "\n",
        "u(c,σ) = c^(1-σ) / (1-σ)\n",
        "\n",
        "function solve_max(V,t,iϵ,ia,pars)\n",
        "    (;agrid,ϵgrid,Π,σ,Ka,r,β) = pars\n",
        "    cash = exp(pars.μ[t] + ϵgrid[iϵ]) + agrid[ia]\n",
        "    amax = 1\n",
        "    vmax = -Inf\n",
        "    loop = true\n",
        "    a = 1\n",
        "    while loop && a<Ka\n",
        "        c = cash - agrid[a] / (1+r)\n",
        "        if c>0\n",
        "            v = u(c,σ)\n",
        "            for iϵ′ in axes(V,1)\n",
        "                v += β * Π[iϵ′,iϵ] * V[iϵ′,a,t+1]\n",
        "            end\n",
        "            if v>vmax\n",
        "                vmax = v\n",
        "                amax = a\n",
        "            end\n",
        "        else\n",
        "            loop = false\n",
        "        end\n",
        "        a += 1\n",
        "    end\n",
        "    return amax,vmax\n",
        "end\n",
        "\n",
        "function iterate!(V,A,t,pars)\n",
        "    for ia in axes(V,2), iϵ in axes(V,1)\n",
        "        A[iϵ,ia,t],V[iϵ,ia,t] = solve_max(V,t,iϵ,ia,pars)\n",
        "    end\n",
        "end\n",
        "\n",
        "function terminal_values!(V,pars)\n",
        "    (;σ,ψ,agrid) = pars\n",
        "    for ia in axes(V,2), iϵ in axes(V,1)\n",
        "        V[iϵ,ia] = ψ * u(agrid[ia],σ)\n",
        "    end\n",
        "end\n",
        "\n",
        "function backward_induction!(V,A,pars)\n",
        "    (;T) = pars\n",
        "    @views terminal_values!(V[:,:,T+1],pars)\n",
        "    for t in reverse(1:T)\n",
        "        iterate!(V,A,t,pars)\n",
        "    end\n",
        "end\n",
        "\n",
        "function setup_and_solve(θ)\n",
        "    β, σ, ψ = θ\n",
        "    T = 45\n",
        "    Ka = 100\n",
        "    Kϵ = 5\n",
        "    ρ = 0.9\n",
        "    ση = 0.1\n",
        "    r = 0.05\n",
        "    μ = fill(2., T)\n",
        "    agrid = collect(LinRange(0, μ[1] * T, Ka))\n",
        "    Π, ϵgrid = tauchen(ρ, ση, Kϵ)\n",
        "    pars = (;T, β, σ, ρ, ση, μ, ψ, r, Ka, Kϵ, agrid, Π, ϵgrid)\n",
        "    V = zeros(Kϵ, Ka, T+1)\n",
        "    A = zeros(Int64, Kϵ, Ka, T)\n",
        "    backward_induction!(V, A, pars)\n",
        "    return A, pars\n",
        "end"
      ],
      "id": "f4d5ea51",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we write a simulation function. Given the policy function, we draw income shocks and track each individual's asset and income path.\n"
      ],
      "id": "c114b2bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function simulate_panel(A, pars, N_sim; seed=nothing)\n",
        "    (;T, Kϵ, Ka, agrid, ϵgrid, Π, μ, r) = pars\n",
        "    if !isnothing(seed)\n",
        "        Random.seed!(seed)\n",
        "    end\n",
        "\n",
        "    # Pre-compute CDF for sampling from Markov chain\n",
        "    cumΠ = cumsum(Π, dims=1)\n",
        "\n",
        "    # Storage\n",
        "    assets = zeros(N_sim, T+1)   # assets at start of each period\n",
        "    income = zeros(N_sim, T)\n",
        "    consumption = zeros(N_sim, T)\n",
        "    iϵ_sim = zeros(Int, N_sim, T)\n",
        "\n",
        "    # Initial conditions: start with zero assets, draw initial ϵ from stationary dist\n",
        "    # Use middle state as starting point for simplicity\n",
        "    iϵ_sim[:, 1] .= (Kϵ + 1) ÷ 2\n",
        "\n",
        "    for n in 1:N_sim\n",
        "        ia = 1  # start with zero assets\n",
        "        for t in 1:T\n",
        "            iϵ = iϵ_sim[n, t]\n",
        "            y = exp(μ[t] + ϵgrid[iϵ])\n",
        "            income[n, t] = y\n",
        "            cash = y + agrid[ia]\n",
        "\n",
        "            # Look up optimal savings\n",
        "            ia_next = A[iϵ, ia, t]\n",
        "            c = cash - agrid[ia_next] / (1 + r)\n",
        "            consumption[n, t] = c\n",
        "            assets[n, t+1] = agrid[ia_next]\n",
        "            ia = ia_next\n",
        "\n",
        "            # Draw next period's ϵ\n",
        "            if t < T\n",
        "                u_draw = rand()\n",
        "                iϵ_next = findfirst(cumΠ[:, iϵ] .>= u_draw)\n",
        "                iϵ_sim[n, t+1] = iϵ_next\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return (;assets, income, consumption)\n",
        "end\n",
        "\n",
        "# Solve and simulate\n",
        "A, pars = setup_and_solve((0.95, 2.0, 5.0))\n",
        "sim = simulate_panel(A, pars, 1000; seed=123)"
      ],
      "id": "d3d97484",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's check the simulation by plotting average assets and consumption over the life cycle.\n"
      ],
      "id": "c6cdb0f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using Plots\n",
        "p1 = plot(1:pars.T, mean(sim.assets[:,1:pars.T], dims=1)', label=\"Mean Assets\",\n",
        "          xlabel=\"Age\", title=\"Life-Cycle Profiles\")\n",
        "plot!(p1, 1:pars.T, mean(sim.consumption, dims=1)', label=\"Mean Consumption\")\n",
        "plot!(p1, 1:pars.T, mean(sim.income, dims=1)', label=\"Mean Income\")"
      ],
      "id": "40f9dbe9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The hump-shaped asset profile and the smooth consumption path are consistent with the model's predictions: individuals accumulate assets during working years and draw them down toward the end of life, with the bequest motive preventing full decumulation.\n",
        "\n",
        ":::\n",
        ":::\n",
        "\n",
        ":::{.callout-note icon=\"false\" collapse=\"true\"}\n",
        "## Example: Simulated Moments for the Savings Model\n",
        ":::{#exm-bootstrap_savings}\n",
        "\n",
        "Now let's use the simulation machinery to define a set of moments and construct an MSM estimator for the preference parameters $(\\beta,\\sigma,\\psi)$. We take the income process parameters $(\\rho,\\sigma_{\\eta})$ as given (estimated in @exm-md_income).\n",
        "\n",
        "Our target moments will be:\n",
        "\n",
        "1. Mean assets at ages 30, 40, 50, 60 (to pin down the savings profile)\n",
        "2. Variance of log consumption at ages 30, 40, 50, 60 (to pin down risk aversion)\n"
      ],
      "id": "4906970c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute moments from simulated data\n",
        "function simulated_moments(θ; N_sim=2000, seed=42)\n",
        "    A, pars = setup_and_solve(θ)\n",
        "    sim = simulate_panel(A, pars, N_sim; seed=seed)\n",
        "    target_ages = [6, 16, 26, 36]  # ages 30, 40, 50, 60 (relative to t=1 at age 25)\n",
        "    m_assets = [mean(sim.assets[:, t]) for t in target_ages]\n",
        "    m_var_logc = [var(log.(sim.consumption[:, t])) for t in target_ages]\n",
        "    return vcat(m_assets, m_var_logc)\n",
        "end\n",
        "\n",
        "# \"True\" parameters and data moments\n",
        "θ_true = (0.95, 2.0, 5.0)\n",
        "m_data = simulated_moments(θ_true; N_sim=10_000, seed=1)\n",
        "\n",
        "# MSM objective\n",
        "function msm_objective(x, m_data)\n",
        "    β = 0.8 + 0.19 * (1 / (1 + exp(-x[1])))  # map to (0.8, 0.99)\n",
        "    σ = exp(x[2])\n",
        "    ψ = exp(x[3])\n",
        "    θ = (β, σ, ψ)\n",
        "    m_sim = simulated_moments(θ)\n",
        "    diff = m_data .- m_sim\n",
        "    return diff' * diff\n",
        "end"
      ],
      "id": "7423e3f2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This estimator is computationally intensive --- each evaluation of the objective requires solving the dynamic programming problem and simulating the model. In practice, derivative-free optimization methods or finite-difference gradients are often used.\n"
      ],
      "id": "ac0be241"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "using Optim\n",
        "x0 = [0.0, log(2.0), log(5.0)]\n",
        "res = optimize(x -> msm_objective(x, m_data), x0, NelderMead(),\n",
        "               Optim.Options(iterations=200, show_trace=true))"
      ],
      "id": "654997c2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "## Indirect Inference\n",
        "\n",
        "**Indirect inference** is a simulation-based estimator that works by fitting an *auxiliary model* to both the real data and to data simulated from the structural model, and then finding the structural parameters that make the two sets of auxiliary estimates as close as possible.\n",
        "\n",
        "### Setup\n",
        "\n",
        "Let $\\hat{\\beta}_{N}$ be a vector of statistics estimated from the data (the \"auxiliary parameters\"). For example, $\\hat{\\beta}$ might be OLS coefficients from a wage regression, or the parameters of a reduced-form probit. The key requirement is that $\\hat{\\beta}$ is asymptotically normal:\n",
        "\n",
        "$$\\sqrt{N}(\\hat{\\beta}_{N}-\\beta_{0})\\rightarrow_{d}\\mathcal{N}(\\mathbf{0},\\Omega)$$\n",
        "\n",
        "Now, for each candidate $\\theta$, simulate data from the structural model and compute the same statistic on the simulated data, yielding $\\hat{\\beta}^{R}(\\theta)$. Let $\\beta(\\theta)=\\text{plim}\\ \\hat{\\beta}^{R}(\\theta)$ denote the \"pseudo-true\" value of the auxiliary parameter implied by $\\theta$. The **indirect inference estimator** is:\n",
        "\n",
        "$$\\hat{\\theta}_{II} = \\arg\\min_{\\theta}\\ (\\hat{\\beta}_{N}-\\hat{\\beta}^{R}(\\theta))'\\mathbf{W}(\\hat{\\beta}_{N}-\\hat{\\beta}^{R}(\\theta))$$\n",
        "\n",
        "### Asymptotic Distribution\n",
        "\n",
        ":::{#thm-ii-asymptotics}\n",
        "## Asymptotic Distribution of Indirect Inference\n",
        "Suppose:\n",
        "\n",
        "1. $\\sqrt{N}(\\hat{\\beta}_{N}-\\beta_{0})\\rightarrow_{d}\\mathcal{N}(\\mathbf{0},\\Omega)$\n",
        "2. $R,N\\rightarrow\\infty$ with $\\sqrt{N}/R\\rightarrow 0$\n",
        "3. $\\theta_{0}$ is the unique solution to $\\beta(\\theta)=\\beta_{0}$ (**identification**)\n",
        "\n",
        "Then:\n",
        "$$\\sqrt{N}(\\hat{\\theta}_{II}-\\theta_{0})\\rightarrow_{d}\\mathcal{N}\\left(\\mathbf{0},\\ (\\nabla_{\\theta}\\beta_{0}\\mathbf{W}\\nabla_{\\theta}\\beta_{0}')^{-1}\\nabla_{\\theta}\\beta_{0}\\mathbf{W}\\Omega\\mathbf{W}\\nabla_{\\theta}\\beta_{0}'(\\nabla_{\\theta}\\beta_{0}\\mathbf{W}\\nabla_{\\theta}\\beta_{0}')^{-1}\\right)$$\n",
        "\n",
        "where $\\nabla_{\\theta}\\beta_{0}=\\frac{\\partial\\beta(\\theta_{0})'}{\\partial\\theta}$.\n",
        ":::\n",
        "\n",
        "The variance formula has the same sandwich structure as minimum distance estimation (@thm-md-asymptotics), which makes sense: indirect inference *is* a simulated minimum distance estimator where the reduced-form statistics play the role of $\\pi$.\n",
        "\n",
        "### Relationship to MSM\n",
        "\n",
        "Indirect inference nests MSM as a special case. If the auxiliary model consists of sample moments $\\hat{\\beta}=\\frac{1}{N}\\sum_{n}g(\\mathbf{w}_{n})$ and the simulated counterpart is $\\hat{\\beta}^{R}(\\theta)=\\frac{1}{NR}\\sum_{r}\\sum_{n}g(\\mathbf{w}_{n}^{r}(\\theta))$, then the indirect inference estimator reduces to MSM. The appeal of indirect inference is that it allows the use of *richer* auxiliary models --- like regressions or multinomial choice models --- that can capture complex features of the data.\n",
        "\n",
        ":::{.callout-warning icon=\"false\"}\n",
        "## Discussion: Choosing Auxiliary Statistics\n",
        "\n",
        "The choice of auxiliary model is both an art and a science. A good auxiliary model should:\n",
        "\n",
        "1. Be sensitive to the structural parameters of interest (for efficiency).\n",
        "2. Capture the key features of the data that the structural model is designed to explain.\n",
        "3. Be computationally cheap to estimate (since it must be re-estimated on each simulated dataset).\n",
        "\n",
        "In practice, it is useful to think of the auxiliary model as a *diagnostic*: if the structural model cannot match the auxiliary estimates, it suggests the model is missing something important. This perspective connects indirect inference to the broader goal of model evaluation.\n",
        ":::\n",
        "\n",
        "\n",
        "## The Bootstrap\n",
        "\n",
        "We now turn to a fundamentally different use of simulation: not for evaluating the objective function, but for **inference**. The **bootstrap** uses resampling to approximate the sampling distribution of an estimator, providing standard errors and confidence intervals without requiring analytical derivations.\n",
        "\n",
        "### Motivation\n",
        "\n",
        "In many settings we face one or more of the following challenges:\n",
        "\n",
        "1. The variance formula is difficult to derive (e.g. for multi-step estimators).\n",
        "2. The derivatives of the criterion function are hard or costly to compute.\n",
        "3. The estimation criterion is non-smooth in finite samples.\n",
        "4. The sample size is too small for the CLT to provide a good approximation.\n",
        "\n",
        "The bootstrap addresses all of these by directly approximating the finite-sample distribution.\n",
        "\n",
        "### Framework\n",
        "\n",
        "Let $T_{N} = T_{N}(X_{1},\\ldots,X_{N})$ be a statistic --- for instance, $T_{N}=\\hat{\\theta}$ or $T_{N}=\\sqrt{N}(\\hat{\\theta}-\\theta_{0})$. The finite-sample distribution $G_{N}(\\cdot,F_{0})$ is typically unknown. The bootstrap idea is to replace $F_{0}$ with an estimate $\\hat{F}_{N}$ and use $G_{N}(\\cdot,\\hat{F}_{N})$ to approximate $G_{N}(\\cdot,F_{0})$.\n",
        "\n",
        "There are two main approaches to constructing $\\hat{F}_{N}$:\n",
        "\n",
        ":::{#def-nonparametric-bootstrap}\n",
        "## Nonparametric Bootstrap\n",
        "Replace $F_{0}$ with the **empirical distribution function**:\n",
        "$$\\hat{F}_{N}(x) = \\frac{1}{N}\\sum_{n=1}^{N}\\mathbf{1}\\{X_{n}\\leq x\\}$$\n",
        "Bootstrap samples are obtained by sampling $N$ observations **with replacement** from the original data.\n",
        ":::\n",
        "\n",
        ":::{#def-parametric-bootstrap}\n",
        "## Parametric Bootstrap\n",
        "Replace $F_{0}$ with $F(\\cdot,\\hat{\\theta}_{N})$, the model-implied distribution evaluated at the estimated parameters. Bootstrap samples are obtained by **simulating** from the estimated model.\n",
        ":::\n",
        "\n",
        "The nonparametric bootstrap is more general and requires fewer assumptions, while the parametric bootstrap can be more efficient when the model is correctly specified. For structural models, the parametric bootstrap is natural since we already have the machinery to simulate from the model.\n",
        "\n",
        "### Procedure\n",
        "\n",
        "Given an estimator $\\hat{\\theta}_{N}$:\n",
        "\n",
        "1. Draw a bootstrap sample of size $N$: $\\mathbf{X}^{b}=\\{X_{1}^{b},\\ldots,X_{N}^{b}\\}$\n",
        "    - **Nonparametric**: sample with replacement from $\\{X_{1},\\ldots,X_{N}\\}$\n",
        "    - **Parametric**: simulate from $F(\\cdot,\\hat{\\theta}_{N})$\n",
        "2. Compute the bootstrap estimate: $\\hat{\\theta}^{b}_{N}=T_{N}(\\mathbf{X}^{b})$\n",
        "3. Repeat steps 1-2 for $b=1,\\ldots,B$ to obtain the bootstrap distribution $\\{\\hat{\\theta}^{1}_{N},\\ldots,\\hat{\\theta}^{B}_{N}\\}$\n",
        "\n",
        "From this distribution we can compute:\n",
        "\n",
        "- **Bootstrap standard errors**: $\\text{se}^{*}(\\hat{\\theta}) = \\text{sd}(\\hat{\\theta}^{1},\\ldots,\\hat{\\theta}^{B})$\n",
        "- **Percentile confidence intervals**: $[q_{\\alpha/2},\\ q_{1-\\alpha/2}]$ where $q_{\\alpha}$ is the $\\alpha$-quantile of the bootstrap distribution\n",
        "- **Bootstrap-$t$ confidence intervals**: based on the distribution of the pivotal statistic $t^{b}=(\\hat{\\theta}^{b}-\\hat{\\theta})/\\text{se}(\\hat{\\theta}^{b})$\n",
        "\n",
        "### When Does the Bootstrap Work?\n",
        "\n",
        "The bootstrap is **consistent** when the statistic $T_{N}$ is asymptotically normal. In this case, $G_{N}(\\cdot,\\hat{F}_{N})\\rightarrow_{p}G_{\\infty}(\\cdot,F_{0})$, so the bootstrap distribution converges to the true asymptotic distribution.\n",
        "\n",
        "The bootstrap can actually do *better* than the asymptotic normal approximation when the statistic is **asymptotically pivotal** --- that is, when its asymptotic distribution does not depend on unknown parameters. The $t$-statistic $\\sqrt{N}(\\hat{\\theta}-\\theta_{0})/\\text{se}(\\hat{\\theta})$ is a canonical example. In this case, the bootstrap provides a higher-order refinement over the normal approximation. See @horowitz2001bootstrap for a detailed discussion.\n",
        "\n",
        ":::{.callout-important}\n",
        "## Replicating the Dependence Structure\n",
        "\n",
        "The bootstrap requires that the resampling scheme correctly replicates the dependence structure in the data. For iid data, sampling with replacement is sufficient. For **panel data**, one should resample entire individuals (not individual observations) to preserve the within-person correlation structure. For time series data, block bootstrap methods are needed.\n",
        ":::\n",
        "\n",
        ":::{.callout-note icon=\"false\" collapse=\"true\"}\n",
        "## Example: Bootstrap Confidence Intervals for the Income Process\n",
        ":::{#exm-bootstrap_income}\n",
        "\n",
        "Let's apply the bootstrap to construct confidence intervals for the income process parameters estimated by minimum distance in @exm-md_income. Rather than relying on the analytical standard errors from @exm-md_income_se, we resample individuals from the PSID panel and re-estimate the parameters on each bootstrap sample.\n",
        "\n",
        "Since the PSID is panel data, we resample **entire individuals** (all observations for a given person) to preserve the within-person correlation.\n"
      ],
      "id": "63c8a2a6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using CSV, DataFrames, DataFramesMeta, Statistics, Optim, Plots, Random\n",
        "\n",
        "# Load and prepare data\n",
        "data_psid = @chain begin\n",
        "    CSV.read(\"../data/abb_aea_data.csv\",DataFrame,missingstring = \"NA\")\n",
        "    @select :person :y :tot_assets1 :asset :age :year\n",
        "    @subset :age.>=25 :age.<=64\n",
        "end\n",
        "\n",
        "# Model moments and estimation functions (from @exm-md_income)\n",
        "function model_moments(θ, T)\n",
        "    ρ, σ2_α, σ2_η = θ\n",
        "    m = [σ2_α + (1-ρ^(2(t-1)))/(1-ρ^2) * σ2_η for t in 1:T]\n",
        "    return m\n",
        "end\n",
        "\n",
        "function md_estimate(data)\n",
        "    m_hat = @chain data begin\n",
        "        groupby(:age)\n",
        "        @combine :var_logy = var(log.(:y))\n",
        "        @orderby :age\n",
        "        _.var_logy\n",
        "    end\n",
        "    T = length(m_hat)\n",
        "\n",
        "    function md_objective(x)\n",
        "        ρ = tanh(x[1])\n",
        "        σ2_α = exp(x[2])\n",
        "        σ2_η = exp(x[3])\n",
        "        θ = (ρ, σ2_α, σ2_η)\n",
        "        m_model = model_moments(θ, T)\n",
        "        diff = m_hat .- m_model\n",
        "        return diff' * diff\n",
        "    end\n",
        "\n",
        "    x0 = [0.5, log(0.1), log(0.05)]\n",
        "    res = optimize(md_objective, x0, Newton(), autodiff=:forward)\n",
        "    x = res.minimizer\n",
        "    return [tanh(x[1]), exp(x[2]), exp(x[3])]\n",
        "end\n",
        "\n",
        "# Point estimate\n",
        "θ_hat = md_estimate(data_psid)\n",
        "println(\"Point estimates: ρ=$(round(θ_hat[1],digits=3)), σ²_α=$(round(θ_hat[2],digits=3)), σ²_η=$(round(θ_hat[3],digits=3))\")"
      ],
      "id": "0ce2f0db",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now the bootstrap. We resample persons with replacement and re-estimate on each bootstrap sample.\n"
      ],
      "id": "0ecbcdb8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "Random.seed!(42)\n",
        "persons = unique(data_psid.person)\n",
        "N_persons = length(persons)\n",
        "B = 200\n",
        "\n",
        "θ_boot = mapreduce(vcat, 1:B) do b\n",
        "    # Resample persons with replacement\n",
        "    boot_persons = persons[rand(1:N_persons, N_persons)]\n",
        "    # Build bootstrap dataset (preserving panel structure)\n",
        "    boot_data = mapreduce(vcat, boot_persons) do p\n",
        "        @subset(data_psid, :person .== p)\n",
        "    end\n",
        "    try\n",
        "        return md_estimate(boot_data)'\n",
        "    catch\n",
        "        return [NaN NaN NaN]\n",
        "    end\n",
        "end\n",
        "\n",
        "# Remove any failed bootstrap replications\n",
        "θ_boot = θ_boot[.!any(isnan.(θ_boot), dims=2)[:], :]\n",
        "\n",
        "# Bootstrap standard errors\n",
        "se_boot = std.(eachcol(θ_boot))\n",
        "println(\"\\nBootstrap standard errors (B=$B):\")\n",
        "println(\"  se(ρ)    = $(round(se_boot[1], digits=4))\")\n",
        "println(\"  se(σ²_α) = $(round(se_boot[2], digits=4))\")\n",
        "println(\"  se(σ²_η) = $(round(se_boot[3], digits=4))\")\n",
        "\n",
        "# 95% percentile confidence intervals\n",
        "ci_lower = [quantile(θ_boot[:,j], 0.025) for j in 1:3]\n",
        "ci_upper = [quantile(θ_boot[:,j], 0.975) for j in 1:3]\n",
        "println(\"\\n95% Confidence Intervals:\")\n",
        "println(\"  ρ:    [$(round(ci_lower[1],digits=3)), $(round(ci_upper[1],digits=3))]\")\n",
        "println(\"  σ²_α: [$(round(ci_lower[2],digits=3)), $(round(ci_upper[2],digits=3))]\")\n",
        "println(\"  σ²_η: [$(round(ci_lower[3],digits=3)), $(round(ci_upper[3],digits=3))]\")"
      ],
      "id": "94aa2ad4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's visualize the bootstrap distributions.\n"
      ],
      "id": "029a10e9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "labels = [\"ρ\", \"σ²_α\", \"σ²_η\"]\n",
        "pl = [begin\n",
        "    histogram(θ_boot[:,j], normalize=:pdf, label=false, alpha=0.5)\n",
        "    plot!([θ_hat[j], θ_hat[j]], [0, ylims()[2]*0.9], color=\"red\",\n",
        "          linewidth=2, label=\"Point Estimate\")\n",
        "    plot!(title=labels[j])\n",
        "end for j in 1:3]\n",
        "plot(pl..., layout=(1,3), size=(900,300))"
      ],
      "id": "22b36ed2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Notice that bootstrapping panel data by resampling individuals is straightforward to implement and automatically accounts for within-person dependence, arbitrary heteroskedasticity, and the full complexity of the minimum distance estimator. Compare these to the analytical standard errors from @exm-md_income_se.\n",
        "\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        ":::{.callout-note icon=\"false\" collapse=\"true\"}\n",
        "## Example: Bootstrap for the Savings Model\n",
        ":::{#exm-bootstrap_savings_model}\n",
        "\n",
        "For the savings model, we use the **parametric bootstrap**. Since we are estimating by MSM using simulated data, the natural bootstrap procedure is:\n",
        "\n",
        "1. Estimate $\\hat{\\theta}$ by MSM.\n",
        "2. Simulate a \"new\" dataset from the model at $\\hat{\\theta}$ (this is the bootstrap sample).\n",
        "3. Re-estimate $\\hat{\\theta}^{b}$ from the bootstrap sample (using the same MSM procedure).\n",
        "4. Repeat to build the bootstrap distribution.\n",
        "\n",
        "Here is a sketch of the procedure. The key idea is that the \"data moments\" in each bootstrap replication come from a fresh simulation at the estimated $\\hat{\\theta}$, mimicking the sampling variability in the real data.\n"
      ],
      "id": "c32810e8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "function parametric_bootstrap(θ_hat, B; N_data=1000, N_sim=2000)\n",
        "    θ_boot = zeros(B, 3)\n",
        "    for b in 1:B\n",
        "        # Step 1: Simulate \"data\" from model at θ̂ (with new random seed)\n",
        "        A, pars = setup_and_solve(θ_hat)\n",
        "        sim_data = simulate_panel(A, pars, N_data; seed=b)\n",
        "\n",
        "        # Step 2: Compute \"data\" moments from simulated data\n",
        "        target_ages = [6, 16, 26, 36]\n",
        "        m_boot = vcat(\n",
        "            [mean(sim_data.assets[:, t]) for t in target_ages],\n",
        "            [var(log.(sim_data.consumption[:, t])) for t in target_ages]\n",
        "        )\n",
        "\n",
        "        # Step 3: Re-estimate by MSM (matching m_boot instead of m_data)\n",
        "        x0 = [0.0, log(θ_hat[2]), log(θ_hat[3])]\n",
        "        res = optimize(x -> msm_objective(x, m_boot), x0, NelderMead(),\n",
        "                       Optim.Options(iterations=200))\n",
        "        x = res.minimizer\n",
        "        θ_boot[b,:] = [0.8 + 0.19/(1+exp(-x[1])), exp(x[2]), exp(x[3])]\n",
        "    end\n",
        "    return θ_boot\n",
        "end\n",
        "\n",
        "# Run bootstrap (computationally intensive!)\n",
        "# θ_boot = parametric_bootstrap(θ_hat, 100)\n",
        "# se_boot = std.(eachcol(θ_boot))"
      ],
      "id": "fa0234e3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Each bootstrap replication requires solving the dynamic programming problem twice (once for the data simulation, once for each objective function evaluation during optimization). This makes the parametric bootstrap for structural models computationally expensive, but it is conceptually simple and automatically accounts for all sources of estimation uncertainty.\n",
        "\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "## Practical Considerations\n",
        "\n",
        "### Simulation Noise and Smoothing\n",
        "\n",
        "When simulation draws are held fixed across evaluations of the objective function, the simulated objective is a smooth function of $\\theta$ (assuming the model itself is smooth in $\\theta$). This means standard gradient-based optimizers can be used. If simulation draws are re-drawn at each evaluation, the objective becomes noisy and optimization may fail or converge to the wrong point. **Always fix the random seed** when evaluating the simulated objective across different $\\theta$ values.\n",
        "\n",
        "### How Many Draws?\n",
        "\n",
        "For MSM, consistency holds for any fixed $R$, but efficiency improves with $R$. A practical approach is to start with a moderate $R$ for exploration, then increase $R$ and check that the estimates are stable. If the estimates change substantially, $R$ is too small.\n",
        "\n",
        "For MSL, the bias from taking logarithms of simulated probabilities is of order $1/R$. In practice, $R$ should be large enough that this bias is negligible relative to the standard error.\n",
        "\n",
        "### Choosing Moments for MSM\n",
        "\n",
        "In @exm-bootstrap_savings, we chose a small set of moments. In practice, the choice of moments should be guided by:\n",
        "\n",
        "1. **Identification**: the moments should be informative about the parameters. Moments that are insensitive to a parameter will not help estimate it.\n",
        "2. **Parsimony**: more moments improve efficiency (in principle) but increase computational cost and can lead to poorly conditioned weighting matrices.\n",
        "3. **Model fit**: if the model cannot match a particular moment, including it will distort the estimates of other parameters. Start with moments the model should be able to match.\n",
        "\n",
        "The discussion in the [identification chapter](identification_savings.qmd) on which moments pin down which preference parameters is directly relevant here.\n",
        "\n",
        "### Diagonal Weighting Matrices\n",
        "\n",
        "When using MSM or minimum distance with many moments, the optimal weighting matrix $\\mathbf{W}^{*}=\\hat{S}^{-1}$ can be poorly estimated and lead to erratic results in finite samples. A common and practical alternative is to use a **diagonal** weighting matrix, where each moment is weighted by the inverse of its variance but cross-moment covariances are ignored. This sacrifices some efficiency but tends to be much more stable in practice.\n",
        "\n",
        "\n",
        "## Exercises\n",
        "\n",
        ":::{.callout-tip icon=\"false\"}\n",
        "## Exercise\n",
        ":::{#exr-savings_estimation}\n",
        "Estimate the preference parameters $(\\beta,\\sigma,\\psi)$ of the [savings model](../models/savings.qmd) using the method of simulated moments. Take the income process parameters as given from @exm-md_income.\n",
        "\n",
        "1. Choose a set of target moments from the PSID data (@exm-psid) that are informative about $(\\beta,\\sigma,\\psi)$. Justify your choice based on the identification discussion in the [savings identification chapter](identification_savings.qmd).\n",
        "2. Implement the MSM estimator using the simulation code from @exm-simulate_savings.\n",
        "3. Report your estimates and plot the model fit for your chosen moments.\n",
        "4. Assess sensitivity: how do the estimates change when you use a different set of moments?\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        ":::{.callout-tip icon=\"false\"}\n",
        "## Exercise\n",
        ":::{#exr-savings_bootstrap}\n",
        "Continuing from @exr-savings_estimation:\n",
        "\n",
        "1. Implement a parametric bootstrap to compute standard errors for $(\\hat{\\beta},\\hat{\\sigma},\\hat{\\psi})$ following the approach in @exm-bootstrap_savings_model. Use $B=100$ bootstrap replications.\n",
        "2. Construct 95% confidence intervals for each parameter.\n",
        "3. Which parameter is most precisely estimated? Which is least? Does this match your intuition from the identification discussion?\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        ":::{.callout-tip icon=\"false\"}\n",
        "## Exercise\n",
        ":::{#exr-income_diagonal}\n",
        "Return to the minimum distance estimation of the income process from @exm-md_income. Instead of using the identity weighting matrix, implement estimation with:\n",
        "\n",
        "1. The **diagonal** weighting matrix, where each moment is weighted by the inverse of the variance of the corresponding sample moment.\n",
        "2. The **optimal** weighting matrix from @exm-md_income_se.\n",
        "\n",
        "Compare the estimates and standard errors across all three weighting schemes. How much does the choice of weighting matrix matter in practice?\n",
        ":::\n",
        ":::"
      ],
      "id": "994f7470"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/Users/mullinsj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}