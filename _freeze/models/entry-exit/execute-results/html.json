{
  "hash": "4566569114bfd518e3f6a5f07ee6b85b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Firm Entry-Exit Model\n\n## Overview\n\nThis section presents a symmetric duopoly model of firm entry and exit decisions. Firms make discrete choices about market participation based on profitability and fixed costs. This model illustrates static discrete choice with strategic interactions and is used in Chapter 5 to demonstrate discrete choice estimation methods.\n\n---\n\n\n## Model Ingredients\n\nHere are the basic ingredients of the model:\n\n- There are two firms indexed by $f\\in\\{0,1\\}$\n- There are $M$ markets indexed by $m$\n- Time is discrete and indexed by $t$\n- Each firm makes an *entry decision* every period. We let $d\\in\\{0,1\\}$ index this decision to enter or not. Let $d(f,m,t)$ indicate the choice of firm $f$ in market $m$ in period $t$.\n- We let $a_{f,m,t}=d(f,m,t-1)$ indicate whether firm $f$ is active in market $m$ in period $t$, which means they entered in the previous period.\n- Let $x_{m}$ be a market-level observable that shifts the profitability of operations in market $m$.\n- In addition to the observed states, each firm draws a pair of idiosyncatic shocks to payoffs in each period, $\\epsilon_{f}=[\\epsilon_{f0},\\epsilon_{f1}]$ that is *private information* to the firm and is iid over markets, firms, and time periods.\n- Firms make their decisions in each period *simultaneously*\n\nTo simplify notation, suppress dependance of outcomes on the market $m$ and time period $t$. Because we are writing a symmetric model, we will also suppress dependence on $f$. The *deterministic* component of the payoff to entering is a function of the market primitives ($x$), the firm's activity status ($a$), and the other firm's entry decision $d^\\prime$:\n\n$$ u_{1}(x,a,d^{\\prime}) = \\phi_{0} + \\phi_{1}x - \\phi_{2}d^\\prime - \\phi_{3}(1-a) $$\n\nThe payoff to not entering is simply:\n\n$${u}_{0}(x,a) = \\phi_{4}a $$\n\nBefore characterizing the solution to the firm's problem, let's code up these payoff functions:\n\n::: {#7796ad34 .cell execution_count=1}\n``` {.julia .cell-code}\nu1(x,a,d′,ϕ) = ϕ[1] + ϕ[2]*x - ϕ[3]d′ + ϕ[4]*(1-a)\nu0(a,ϕ) = a * ϕ[5]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nu0 (generic function with 1 method)\n```\n:::\n:::\n\n\n## Solving the firm's problem\n\nLet $d^*(x,a,a',\\epsilon)$ be the firm's optimal decision given the state and the idiosyncratic shock. We will focus on *symmetric equilibria* so this policy function is sufficient to describe the behavior of both firms. \n\nThe value to either firm of arriving in a period with state $(x,a,a')$ can be written recursively as:\n\n$$\n\\begin{aligned}\nV(x,a,a') = \\mathbb{E}_{\\epsilon}\\max\\mathbb{E}_{\\epsilon'}\\big\\{\n    &u_{1}(x,a,d^*(x,a',a,\\epsilon'))+\\epsilon_{1} \\\\\n    &\\quad + \\beta V(x,1,d^*(x,a,a',\\epsilon')), \\\\\n    &u_{0}(x,a) + \\epsilon_{0} \\\\\n    &\\quad + \\beta V(x,0,d^*(x,a',a,\\epsilon'))\\big\\}\n\\end{aligned}\n$$\n\nDefine the optimal choice probability in equilibrium as:\n\n$$ p(x,a,a') = \\int_{\\epsilon}d^*(x,a,a',\\epsilon)dF(\\epsilon) $$\n\nWith this in hand we can integrate out the other firm's shocks $\\epsilon'$ to get:\n\n$$\n\\begin{aligned}\nV(x,a,a') = \\mathbb{E}_{\\epsilon}\\max\\big\\{\n    &\\phi_{0}+\\phi_{1}x - \\phi_{2}p(x,a',a) +\\epsilon_{1} \\\\\n    &\\quad + \\beta \\big[p(x,a',a)V(x,1,1) + (1-p(x,a',a))V(x,1,0)\\big], \\\\\n    &a \\phi_{4} + \\epsilon_{0} \\\\\n    &\\quad + \\beta \\big[p(x,a',a)V(x,0,1) + (1-p(x,a',a))V(x,0,0)\\big]\\big\\}\n\\end{aligned}\n$$\n\nDefine the choice-specific values as:\n\n$$\n\\begin{aligned}\nv_{1}(x,a,a') = \\phi_{0}+\\phi_{1}x &- \\phi_{2}p(x,a',a) \\\\\n    &+ \\beta \\big[p(x,a',a)V(x,1,1) + (1-p(x,a',a))V(x,1,0)\\big]\n\\end{aligned}\n$$\n\nand\n\n$$\n\\begin{aligned}\nv_{0}(x,a,a') = a \\phi_{4} + \\beta \\big[p(x,a',a)V(x,0,1) + (1-p(x,a',a))V(x,0,0)\\big]\n\\end{aligned}\n$$\n\nSo assuming that $\\epsilon$ is distributed as type I extreme value random variable with location parameter 0 and scale parameter 1 we get analytical expressions for the choice probabilities and the expected value of the maximum:\n\n$$ V(x) = \\gamma + \\log\\left(\\exp(v_{0}(x,a,a'))+\\exp(v_{1}(x,a,a'))\\right)$$\n\nwhere $\\gamma$ is the [Euler-Mascheroni constant](https://en.wikipedia.org/wiki/Euler%27s_constant) and\n\n$$ p(x,a,a') = \\frac{\\exp(v_{1}(x,a,a'))}{\\exp(v_{0}(x,a,a'))+\\exp(v_{1}(x,a,a'))} $$\n\nBefore we define equilibrium and think about solving the model, let's quickly write up the mapping between the other firm's choice probabilities and the choice values:\n\n::: {#8d82d14d .cell execution_count=2}\n``` {.julia .cell-code}\n# Fixing x, assume that V is stored as a 2 x 2 array\n# The argument p is the current guess of p(x,a',a)\nfunction choice_values(x,a,p,V,ϕ,β)\n    v0 = u0(a,ϕ) + β * p * V[1,2] + β * (1-p) * V[1,1]\n    v1 = u1(x,a,p,ϕ) + β * p * V[2,2] + β * (1-p) * V[2,1]\n    return v0,v1\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nchoice_values (generic function with 1 method)\n```\n:::\n:::\n\n\nIn principle we could iterate on this mapping to find (for a fixed $p$), the firm's optimal solution. But that won't be an efficient way to try and solve for the equilibrium.\n\n## Equilibrium\n\nThe solution concept for this model is *Markov Perfect Equilibrium*. Fixing the market $x$, here the equilibrium be characterized as a fixed point in the value function $V$ and choice probabilities, $p$. In words, equilibrium is summarized by a $V$ and a $p$ such that:\n\n1. Given $p$, $V$ is a fixed point in the recursive formulation of values; and\n2. $p$ are the optimal choice probabilities of each firm given $V$ and given the other firm's choice probabilities are $p$.\n\nHow should we solve for this symmetric equilibrium? We could try iterating on $V$ and $p$ as follows:\n\n::: {#f99ff97b .cell execution_count=3}\n``` {.julia .cell-code}\n# V is a 2x2 array with values\n# p is a 2x2 array with choice probabilities\nfunction iterate_model(V,p,x,ϕ,β)\n    Vnew = copy(V)\n    pnew = copy(p)\n    for a′ in axes(V,2)\n        for a in axes(V,1)\n            p′ = p[a′,a]\n            v0,v1 = choice_values(x,a-1,p′,V,ϕ,β)\n            pnew[a,a′] = exp(v1) / (exp(v0)+exp(v1))\n            Vnew[a,a′] = log(exp(v0)+exp(v1))\n        end\n    end\n    return Vnew,pnew\nend\n\nfunction solve_by_iteration(x,ϕ,β; max_iter = 1000, verbose = false)\n    V0 = zeros(2,2)\n    p0 = fill(0.1,2,2)\n    err = Inf\n    iter = 1\n    while err>1e-10 && iter<max_iter\n        V1,p1 = iterate_model(V0,p0,x,ϕ,β)\n        err = maximum(abs.(V1 .- V0))\n        if mod(iter,100)==0 && verbose\n            println(\"Iteration $iter, error is $err\")\n        end\n        V0 = V1\n        p0 = p1\n        iter += 1\n    end\n    return V0,p0\nend\n\nβ = 0.95\nϕ = 2 * [1.,0.1,0.5,2.,0.5]\nsolve_by_iteration(0.,ϕ,β; verbose = true)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 100, error is 0.04823924738592211\nIteration 200, error is 0.001242310554474102\nIteration 300, error is 5.032709619001707e-5\nIteration 400, error is 2.123540213005981e-6\nIteration 500, error is 8.863101186307176e-8\nIteration 600, error is 3.693557459882868e-9\nIteration 700, error is 1.538467131467769e-10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n([69.73147518902888 70.96824731388737; 68.46263413289174 67.89546273371974], [0.9107652821657111 0.990549524651413; 0.052475860075290155 0.27729654446688445])\n```\n:::\n:::\n\n\nThis seems to work! But notice that it takes a while for the iteration to converge. Also, unlike the single agent case, there is no guarantee that this iteration is always a contraction. \n\nWe can also solve this model relatively easily using Newton's Method and the magic of [Automatic Differentiation](/appendices/autodiff.qmd). To do this, we'll solve over the pair of choice-specific values $v_{0}$ and $v_{1}$ (these encode both values and choice probabilities) and store these values as a vector instead of an array:\n\n::: {#73e46181 .cell execution_count=4}\n``` {.julia .cell-code}\nusing ForwardDiff, LinearAlgebra\n\n# this function returns V as a 2 x 2 array given the vector of choice specific values in V\nfunction calc_V(v)\n    idx = LinearIndices((2,2,2))\n    [log(exp(v[idx[1,1+a,1+a′]]) + exp(v[idx[2,1+a,1+a′]])) for a in 0:1, a′ in 0:1]\nend\n\n# this function returns choice probabilities as a 2x2 array given the vector v\nfunction calc_p(v)\n    idx = LinearIndices((2,2,2))\n    [1 / (1+exp(v[idx[1,1+a,1+a′]] - v[idx[2,1+a,1+a′]])) for a in 0:1, a′ in 0:1]\nend\n\n\nfunction iterate_model_v(v,x,ϕ,β)\n    idx = LinearIndices((2,2,2)) #<- this is for convenient indexing over v\n    vnew = copy(v)\n    V = calc_V(v)\n    for a′ in axes(idx,3)\n        for a in axes(idx,2)\n            i0′ = idx[1,a′,a] #<- this locates the position in v for v_{0}(x,a',a)\n            i1′ = idx[2,a′,a] #<- this locates the position in v for v_{1}(x,a',a)\n            p = 1 / (1 + exp(v[i0′] - v[i1′]))\n            v0,v1 = choice_values(x,a-1,p,V,ϕ,β)\n            vnew[idx[1,a,a′]] = v0\n            vnew[idx[2,a,a′]] = v1\n        end\n    end\n    return vnew\nend\n\nF(v,x,ϕ,β) = v .- iterate_model_v(v,x,ϕ,β)\nfunction solve_model_newton(x,ϕ,β;max_iter = 10, verbose = false)\n    v = zeros(8)\n    dF(v) = ForwardDiff.jacobian(y->F(y,x,ϕ,β),v)\n    err = Inf\n    iter = 1\n    while (err>1e-10) && (iter<max_iter)\n        Fv = F(v,x,ϕ,β)\n        dFv = dF(v)\n        vnew = v - inv(dFv) * Fv\n        err = maximum(abs.(Fv))\n        if verbose\n            println(\"Iteration $iter, error is $err\")\n        end\n        iter += 1\n        v = vnew\n    end\n    return v\nend\n\nsolve_model_newton(0.,ϕ,β;verbose = true);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 1, error is 6.158489821531948\nIteration 2, error is 1.7766463237555712\nIteration 3, error is 0.056247498263360285\nIteration 4, error is 0.00028434628951856666\nIteration 5, error is 3.4473004006940755e-8\nIteration 6, error is 1.4210854715202004e-14\n```\n:::\n:::\n\n\nLet's try timing each solution method to quickly compare:\n\n::: {#4f5d17fc .cell execution_count=5}\n``` {.julia .cell-code}\nsolve_model_newton(0.,ϕ,β)\nsolve_by_iteration(0.,ϕ,β)\n\n@time solve_model_newton(0.,ϕ,β)\n@time solve_by_iteration(0.,ϕ,β)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000092 seconds (230 allocations: 54.688 KiB)\n  0.000331 seconds (4.29 k allocations: 234.531 KiB)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n([69.73147518902888 70.96824731388737; 68.46263413289174 67.89546273371974], [0.9107652821657111 0.990549524651413; 0.052475860075290155 0.27729654446688445])\n```\n:::\n:::\n\n\nIn this case Newton's method is faster. Let's double check that both methods return the same answer:\n\n::: {#d5340936 .cell execution_count=6}\n``` {.julia .cell-code}\nv0 = solve_model_newton(0.,ϕ,β)\nV0,p = solve_by_iteration(0.,ϕ,β)\np1 = calc_p(v0)\n[p p1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n2×4 Matrix{Float64}:\n 0.910765   0.99055   0.910765   0.99055\n 0.0524759  0.277297  0.0524759  0.277297\n```\n:::\n:::\n\n\nLooks good! We can re-use this code when we get to thinking about estimation later on. To do this we will have to solve the model for different values of $x_{m}$, but that can be done by using this code and iterating (potentially in parallel) over different values of $x$.\n\nIf you play around with parameters, you will see how convergence times may change and that solution methods are not always stable, especially when choice probabilities in equilibrium are very close to one or zero.\n\n## Further Redaing\n\n@EricsonPakes1995 and @Aguirregabiria2007 are both classic entries in this literature.\n\n",
    "supporting": [
      "entry-exit_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}