{
  "hash": "d78ffa337c7fc66728d7938c9ac77665",
  "result": {
    "engine": "jupyter",
    "markdown": "# A Life-Cycle Savings Model\n\n## Overview\n\nThis section presents a stylized life-cycle model of consumption and savings. Households make dynamic decisions about consumption and asset accumulation over their lifetime, facing income uncertainty and borrowing constraints. \n\n## Economic Environment\n\nTime is discrete and indexed by $t$. Individuals live for a finite number of periods, $T$. They derive utility from consumption according to a CRRA utility function: \n\n$$ u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma} $$\n\nand from \"bequests\", which are modeled here as cash on hand net of consumption in the final period:\n\n$$ \\nu(a) = \\psi \\frac{a^{1-\\sigma}}{1-\\sigma} $$.\n\nConsumption can be transferred between periods via a portfolio of one-period bonds (\"savings', $a$) that can be purchased at the price $1 / (1+r)$, with a prdetermined limit, $\\underline{a}$, on borrowing.\n\nInviduals receive income $y$ every period that is governed by a deterministic ($\\mu_{t}$) and stochastic component:\n\n$$ \\log(y_{t}) = \\mu_{t} + \\varepsilon_{it} $$\n\nwhere $\\varepsilon_{it}$ is a first-order Markov process. A particular case of interest is the case where $\\varepsilon$ is a stationary AR 1 process:\n\n$$ \\varepsilon_{it} = \\rho \\varepsilon_{it-1} + \\eta_{it} $$\n\nwhere $\\eta_{it} \\sim \\mathcal{N}(0,\\sigma^2_{\\eta})$. The unconditional variance of $\\varepsilon_{it}$ is therefore $\\sigma^2_{\\eta} / (1-\\rho^2)$.\n\n## Model Solution\n\nDefine\n\n$$ V_{T}(a,\\varepsilon) = \\max_{c}\\left\\{u(c) + \\nu(y + a - c)\\right\\} $$\n\nAnd now define the remaining value functions recursively:\n\n$$ V_{t}(a,\\varepsilon) = \\max_{c,a'}\\left\\{u(c) + \\beta\\mathbb{E}_{\\varepsilon'|\\varepsilon}V(a',\\varepsilon')\\right\\} $$\n\nsubject to:\n\n$$ c + \\frac{1}{1+r}a' \\leq y + a $$\n\nand \n\n$$ a' \\geq \\underline{a}$$\n\nwhere $\\underline{a}$ is the borrowing constraint.\n\nWe're going to write code to solve the model naively using this recursive formulation. You may already be aware that there are more efficient solution methods that exploit the first order conditions of the problem. Not the focus of our class! Please don't use the example below as a demonstration of best practice when it comes to solving savings models.\n\nWe'll start picking some default parameters.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\npars = (;\n    T = 45, β = 0.95, σ = 2,ρ = 0.9,ση = 0.1, μ = fill(2.,45), ψ = 5., r = 0.05\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n(T = 45, β = 0.95, σ = 2, ρ = 0.9, ση = 0.1, μ = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0  …  2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], ψ = 5.0, r = 0.05)\n```\n:::\n:::\n\n\nNext we'll write a function that uses Tauchen's method to approximate the income process as a discrete markov process.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing Distributions,Random\nusing LinearAlgebra\nΦ(x) = cdf(Normal(),x)\n\nfunction tauchen(ρ,ση,Kϵ)\n    sd = ση/sqrt(1-ρ^2)\n    grid = range(-3sd,stop=3sd,length=Kϵ)\n    Π = zeros(Kϵ,Kϵ)\n    Δ = grid[2]-grid[1]\n    for j=1:Kϵ\n        Π[1,j] = Φ((grid[1] + Δ/2 - ρ*grid[j])/ση)\n        Π[end,j] = 1 - Φ((grid[end] - Δ/2 - ρ*grid[j])/ση)\n        for k=2:(Kϵ-1)\n            Π[k,j] = Φ((grid[k] + Δ/2 - ρ*grid[j])/ση) - Φ((grid[k] - Δ/2 - ρ*grid[j])/ση)\n        end\n    end\n    return Π,grid\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\ntauchen (generic function with 1 method)\n```\n:::\n:::\n\n\nNow, let's think about how to solve this model. We have two state variables to track. We have discretized $\\varepsilon$, now let's discretize assets and define a max operator.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nKa = 100\nKϵ = 5\nagrid = LinRange(0,pars.μ[1] * pars.T,Ka) #<- is this a reasonable upper bound? We'll find out!\nΠ,ϵgrid = tauchen(pars.ρ,pars.ση,Kϵ)\npars = (;pars...,Ka,agrid,Π,ϵgrid,Kϵ)\n\nu(c,σ) = c^(1-σ) / (1-σ)\n\nfunction solve_max(V,t,iϵ,ia,pars)\n    (;agrid,ϵgrid,Π,σ,Ka,r,β) = pars\n    cash = exp(pars.μ[t] + ϵgrid[iϵ]) + agrid[ia]\n    amax = 0\n    vmax = -Inf\n    loop = true\n    a = 1\n    while loop && a<Ka\n        c = cash - agrid[a] / (1+r)\n        if c>0\n            #@views v = u(c,σ) + β * dot(Π[:,iϵ],V[:,a,t+1])\n            v = u(c,σ)\n            for iϵ′ in axes(V,1)\n                v += β * Π[iϵ′,iϵ] * V[iϵ′,a,t+1]\n            end\n            if v>vmax\n                vmax = v\n                amax = a\n            end\n        else\n            loop = false\n        end\n        a += 1 #<- move one up the grid space\n    end\n    return amax,vmax\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nsolve_max (generic function with 1 method)\n```\n:::\n:::\n\n\nNext, a function that uses this max operator to get the value function for all states in a period, $t$, and records the optimal savings policy.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nfunction iterate!(V,A,t,pars)\n    for ia in axes(V,2), iϵ in axes(V,1)\n        A[iϵ,ia,t],V[iϵ,ia,t] = solve_max(V,t,iϵ,ia,pars)\n    end\nend\nfunction terminal_values!(V,pars)\n    (;σ,ψ,agrid) = pars\n    for ia in axes(V,2), iϵ in axes(V,1)\n        V[iϵ,ia] = ψ * u(agrid[ia],σ)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nterminal_values! (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction backward_induction!(V,A,pars)\n    (;ψ,σ,T,agrid) = pars\n    # set the values at T+1 (bequest motives)\n    @views terminal_values!(V[:,:,T+1],pars)\n    for t in reverse(1:T)\n        iterate!(V,A,t,pars)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nbackward_induction! (generic function with 1 method)\n```\n:::\n:::\n\n\nLet's check the model solution and time it also.\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nV = zeros(pars.Kϵ,pars.Ka,pars.T+1)\nA = zeros(Int64,pars.Kϵ,pars.Ka,pars.T)\nbackward_induction!(V,A,pars)\n@time backward_induction!(V,A,pars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.009247 seconds\n```\n:::\n:::\n\n\nSeems ok. We can plot the policy functions as a sanity check. The plot below shows savings policy at the median wage shock over time at different levels of assets.\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nusing Plots\n\nplot(1:pars.T,agrid[A[3,1:10:Ka,:]'],legend=false)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](savings_files/figure-pdf/cell-8-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\nYou can see that the discreteness creates some jumpiness in the policy functions. As I said, other solution methods that use interpolation can be more efficient and will create smoother pictures, but since that is not the focus of this class we will use this simple solution method.\n\n",
    "supporting": [
      "savings_files/figure-pdf"
    ],
    "filters": []
  }
}